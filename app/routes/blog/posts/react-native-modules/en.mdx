---
meta:
  name: "react-native-modules"
  title: "Linking Dependencies inside of React Native View Modules for iOS"
  description: "In depth tutorial on how to link frameworks/libraries to your native view modules when building a react native package for iOS and Android."
  date: "2023-09-01T10:18:29+0000"
  tags: ["react", "react-native", "ios", "packages", "native modules"]
headers:
  Cache-Control: max-age=604800
---

# Linking Dependencies Inside React Native View Modules for iOS

I'll start this blog **post** by saying that I have gained tremendous respect **for** my colleagues who use React Native day in and day out. The sheer number of tools **needed** to run and compile a single React Native project is truly overwhelming.

## Introduction

### The Promise

[React Native](https://reactnative.dev/) promises to significantly reduce the workload needed to produce a multi-platform app. With just a single JavaScript‚Ñ¢Ô∏è project, an individual can create both an iOS and Android app that offer consistent behavior and appearance.

### The reality

When building a custom experiences like the one I was required to build form my client you realize that you now need to have 3 integrated development environments running side-by-side to actually get the app running.

After the hassle of now having your attention spread across 3 different contexts (iOS, Web and Android) you need to handle platform specific errors which are hard to debug due to the obscurity of each error and a non existing debugging tool for React Native.

Let's only hope that God, Google and ChatGPT can help you with it...

### The problem

We are trying to build a so called [React Native Native Component iOS](https://reactnative.dev/docs/native-components-ios) that leverages a native Swift‚Ñ¢Ô∏è [XCFramework](https://developer.apple.com/documentation/xcode/creating-a-multi-platform-binary-framework-bundle) called [Wowza Flowplayer Apple SDK](https://github.com/flowplayer/apple-sdk-releases) that was built by me.

> The _Wowza Flowplayer Apple SDK_ is a fully integrate video player that allows you to play: VODs, Livestreams and other types of media. It is small and customizable player that is easy to integrate and should run smoothly as it doesn't require many resources of the device due to it's architecture.

## Step 1: Setting up the project

Starting of the project using the [react-native-cli](https://www.npmjs.com/package/react-native-cli) and manually linking the `Native Module` turned into a mess due to all the linking required in your project

The linking should look something like this:

```
Native Module -> React Native -> Example App
```

If you are thinking to start of and manually connect everything I highly advise against as the process is almost impossible to get right without serious knowledge in all 3 platforms (Web, iOS and Android).

The recommended way to get started is by using the [react-native-builder-bob](https://github.com/callstack/react-native-builder-bob) CLI from [Callstack‚Ñ¢Ô∏è](https://callstack.com?utm_source=rashadatjou). Which is a delight to use and will get you up and running in no time.

Following the docs you are going to run:

```bash
¬ª npx create-react-native-library@latest my-library
```

Answer the questions of the CLI:

```bash
? What is the name of the npm package? ‚Ä∫ <NAME>

? What is the description for the package? ‚Ä∫ <DESCRIPTION>

? What is the name of package author? ‚Ä∫ <DEVELOPER>

? What is the email address for the package author? ‚Ä∫ <EMAIL>

? What is the URL for the package author? ‚Ä∫ <URL>

? What is the URL for the repository? ‚Ä∫ <GIT_URL>

? What type of library do you want to develop? ‚Ä∫ - Use arrow-keys. Return to submit.
    JavaScript library - supports Expo Go and Web
    Native module
 ‚ùØ  Native view
    Turbo module with backward compat
    Turbo module
    Fabric view with backward compat
    Fabric view

? Which languages do you want to use? ‚Ä∫ - Use arrow-keys. Return to submit.
    Java & Objective-C
    Kotlin & Objective-C
    Java & Swift
‚ùØ   Kotlin & Swift
```

After the questioner the CLI will create your project and you will get the following message:

```bash
‚úî Project created successfully at awesome-library!

Get started with the project:

  $ yarn

Run the example app on iOS:

  $ yarn example ios

Run the example app on Android:

  $ yarn example android
```

All that is left for us to do is `cd` into our project root and install the ungodly amount of dependencies need for this monstrosity to run.

```bash
¬ª cd my-library
¬ª yarn
```

## Step 2: Exploring up the project

The project comes bundled with a lot of tooling that is useful but in our scenario will only provide us with software bloat. While explaining the project and it's structure I will also delete some of the not so needed files and utilities along the way.

```bash
¬ª ls -a
‚Äì .editorconfig
‚Äì .git
‚Äì .gitattributes
‚Äì .github
‚Äì .gitignore
‚Äì .nvmrc
‚Äì .watchmanconfig
‚Äì .yarnrc
‚Äì android
‚Äì babel.config.js
‚Äì CODE_OF_CONDUCT.md
‚Äì CONTRIBUTING.md
‚Äì example
‚Äì ios
‚Äì lefthook.yml
‚Äì LICENSE
‚Äì node_modules
‚Äì package.json
‚Äì react-native-awesome-library.podspec
‚Äì README.md
‚Äì scripts
‚Äì src
‚Äì tsconfig.build.json
‚Äì tsconfig.json
‚Äì turbo.json
‚Äì yarn.lock
```

As shown above the scaffold project is huge and to make it easier for everyone to follow along we will delete certain files and remove tools that uses them. But first let's explain all the files above and what they do:

**`.editorconfig`** ‚Äì [editorconfig.org](https://editorconfig.org)

EditorConfig helps maintain consistent coding styles for multiple developers working on the same project across various editors and IDEs.

**`.git`**

This is a directory where Git stores metadata and object files for the repository. It's the heart of the Git version control system.

**`.gitattributes`**

Configuration file for Git that can define attributes for paths, such as handling line endings or marking paths as export-ignore.

**`.github`** ‚Äì [github.com](https://docs.github.com/en/actions/using-workflows)

This directory often contains GitHub-specific configurations, such as workflows for GitHub Actions or templates for issues and pull requests.

**`.gitignore`**

A file that specifies intentionally untracked files that Git should ignore when performing operations.

**`.nvmrc`** ‚Äì [nvm-sh](https://github.com/nvm-sh/nvm#nvmrc)

Contains a version number that tells nvm (Node Version Manager) which version of Node.js to use for the project.

**`.watchmanconfig`** ‚Äì [watchman](https://facebook.github.io/watchman/)

Configuration file for Watchman, a tool by Facebook that watches for file changes.

**`.yarnrc`** ‚Äì [yarn](https://yarnpkg.com/)

Configuration file for Yarn, a JavaScript package manager. It may contain settings like registry URL or package installation settings.

**`android`**

This directory contains the native code for the Android platform.

**`babel.config.js`** ‚Äì [babeljs.io](https://babeljs.io/)

Configuration file for Babel, a JavaScript transpiler. It helps convert ES6/ES7 JavaScript code into a version that can run in current JavaScript engines.

**`CODE_OF_CONDUCT.md`**

Guidelines for how contributors should behave within the community.

**`CONTRIBUTING.md`** [contributing.md](https://contributing.md/)

Guidelines for people who want to contribute to the project.

**`example`**

Example or demo application that uses the library/module being developed.

**`ios`**

This directory contains the native code for the iOS platform.

**`lefthook.yml`** ‚Äì [evilmartians/lefthook](https://github.com/evilmartians/lefthook)

Configuration file for `Lefthook`, a fast and powerful Git hooks manager.

**`LICENSE`**

Specifies the license for the project. It defines how the software can be used and distributed.

**`node_modules`**

Folder where all the modules and libraries are stored after they're installed via yarn.

**`package.json`**

Contains metadata about the project, like its dependencies, scripts, version, etc.

**`react-native-awesome-library.podspec`**

A specification file for CocoaPods, which is a dependency manager for Swift and Objective-C. It describes the properties of the native module for iOS.

**`README.md`**

Documentation for the project. It gives an overview of what the project does, how to set it up, and other essential information.

**`scripts`**

Typically contains custom scripts that help in various project operations, like building or deployment.

**`src`**

TypeScript Source code directory of the project.

**`tsconfig.build.json`** ‚Äì [typescriptlang.org/tsconfig](https://www.typescriptlang.org/tsconfig)

TypeScript compiler configuration specific for building the project.

**`tsconfig.json`** ‚Äì [typescriptlang.org/tsconfig](https://www.typescriptlang.org/tsconfig)

Base TypeScript compiler configuration for the project.

**`turbo.json`** ‚Äì [turbo.build/repo](https://turbo.build/repo)

Configuration for Turbo, which might be related to speeding up builds or other tasks within the project.

**`yarn.lock`**

Automatically generated file by Yarn that locks the installed versions of each package to ensure consistency across environments.

> Okay... so you only need to know 13 different tools/technologies nothing to worry about üòÖ

## Step 3: Exploring the Code

The part of the code that I will cover here is only going to be the JavaScript‚Ñ¢Ô∏è and iOS. I won't cover the Android side in this tutorial FYI.

### Javascript

If we open the `src` directory we can find the actual TypeScript code that we are going to need to integrate. The structure is pretty simple:

```bash
¬ª cd src
¬ª ls -R

‚Äì index.tsx
‚Äì __tests__/
  ‚Äì index.test.tsx
```

Now lets look into the index.tsx and see what fun things are waiting for us inside:

```bash
¬ª cat index.tsx
```

```javascript
import {
  requireNativeComponent,
  UIManager,
  Platform,
  type ViewStyle,
} from "react-native";

const LINKING_ERROR =
  `The package 'react-native-awesome-library' doesn't seem to be linked. Make sure: \n\n` +
  Platform.select({ ios: "- You have run 'pod install'\n", default: "" }) +
  "- You rebuilt the app after installing the package\n" +
  "- You are not using Expo Go\n";

type AwesomeLibraryProps = {
  color: string,
  style: ViewStyle,
};

const ComponentName = "AwesomeLibraryView";

export const AwesomeLibraryView =
  UIManager.getViewManagerConfig(ComponentName) != null
    ? requireNativeComponent < AwesomeLibraryProps > ComponentName
    : () => {
        throw new Error(LINKING_ERROR);
      };
```

What is happening in the file:

1. We are importing all the necessary dependencies from the `react-native` module.
2. We are setting up a linking error message for anyone who is going to use this module explaining him why it might be broken.
3. We are declaring the `types` our `view` accepts (these properties should be the ones exported from the native iOS/Android side).
4. We are declaring the name of our `view` (this is the name of the actual native `view` from iOS/Android).
5. We are trying to load the actual `view` using the `requireNativeComponent` and if we have done so successfully we export it so that it can be used inside of our React Native module.

### iOS

With the understanding who the JavaScript‚Ñ¢Ô∏è side now works. Let's go the iOS side and see what we have there.

```bash
¬ª cd ../
¬ª cd ios/
¬ª ls -R

‚Äì AwesomeLibrary-Bridging-Header.h
‚Äì AwesomeLibraryViewManager.m
‚Äì AwesomeLibrary.xcodeproj/
‚Äì AwesomeLibraryViewManager.swift
```

At the first glance it looks like a simple boilerplate code for `Objective-C` library. Let's read the files one by one and see what awaits us there.

**AwesomeLibrary-Bridging-Header.h**

```bash
¬ª cat AwesomeLibrary-Bridging-Header.h
```

```swift
#import <React/RCTViewManager.h>
```

The so called Bridging-Header file is a `Objective-C` header file which links our `Swift` code with `Objective-C`. This header file loads the `React/RCTViewManager` header so that we can use it our `Swift` files.

**AwesomeLibraryViewManager.m**

```bash
¬ª cat AwesomeLibraryViewManager.m
```

```swift
#import <React/RCTViewManager.h>

@interface RCT_EXTERN_MODULE(AwesomeLibraryViewManager, RCTViewManager)

RCT_EXPORT_VIEW_PROPERTY(color, NSString)

@end
```

We are again importing the the `RCTViewManager`

The official React Native documentation states the following about the `RCTViewManager`:

> Native views are created and manipulated by subclasses of RCTViewManager. These subclasses are similar in function to view controllers, but are essentially singletons - only one instance of each is created by the bridge

We learn that `RCTViewManager` is what is actually going to represent our `view` in our Javascript code. We are creating here and exporting at the same time `AwesomeLibraryViewManager` which has a single property `color: NSString`.

**AwesomeLibraryViewManager.swift**

```bash
¬ª cat AwesomeLibraryViewManager.swift
```

```swift
@objc(AwesomeLibraryViewManager)
class AwesomeLibraryViewManager: RCTViewManager {

  override func view() -> (AwesomeLibraryView) {
    return AwesomeLibraryView()
  }

  @objc override static func requiresMainQueueSetup() -> Bool {
    return false
  }
}

class AwesomeLibraryView : UIView {

  @objc var color: String = "" {
    didSet {
      self.backgroundColor = hexStringToUIColor(hexColor: color)
    }
  }

  func hexStringToUIColor(hexColor: String) -> UIColor {
    let stringScanner = Scanner(string: hexColor)

    if(hexColor.hasPrefix("#")) {
      stringScanner.scanLocation = 1
    }
    var color: UInt32 = 0
    stringScanner.scanHexInt32(&color)

    let r = CGFloat(Int(color >> 16) & 0x000000FF)
    let g = CGFloat(Int(color >> 8) & 0x000000FF)
    let b = CGFloat(Int(color) & 0x000000FF)

    return UIColor(red: r / 255.0, green: g / 255.0, blue: b / 255.0, alpha: 1)
  }
}
```

So here is the actual implementation of the Native Swift UI... I was wondering after all those files we saw where the actual code is located.

The important thing to note here is that we are exposing our Swift code to Objective-C using the` @objc` attribute. The native code that is then used by React Native is actually a Static Objective-C Library. To comply with that, we need to expose our `AwesomeLibraryViewManager` as an Objective-C class. The `AwesomeLibraryView` which inherits from the `UIView` class in `UIKit`, an Objective-C UI framework, doesn't need to be annotated. However, the `color: String` instance property needs the `@objc` annotation to be exposed to Objective-C.

## Step 4: Adding 3rd party Swift Dependencies

This part proved to be more tricky then it should be due to missing documentation on the React Native site. If we go to the official docs and see how to import 3rd party dependencies we will see [this](https://reactnative.dev/docs/linking-libraries-ios). The docs show us that we need to drag and drop our libraries/frameworks into our project and then we are going to be able to actually use them.

In our scenario this is wrong and it should not be done this way! If we want to setup a proper development environment so that we don't need to manage our dependency versions and other knick-knacks we are going to use `CocoaPods` and the already present `.podspec` file that was generated for us.

Let's open the `react-native-awesome-library.podspec` file and see what we have:

```ruby
require "json"

package = JSON.parse(File.read(File.join(__dir__, "package.json")))
folly_compiler_flags = '-DFOLLY_NO_CONFIG -DFOLLY_MOBILE=1 -DFOLLY_USE_LIBCPP=1 -Wno-comma -Wno-shorten-64-to-32'

Pod::Spec.new do |s|
  s.name         = "react-native-awesome-library"
  s.version      = package["version"]
  s.summary      = package["description"]
  s.homepage     = package["homepage"]
  s.license      = package["license"]
  s.authors      = package["author"]

  s.platforms    = { :ios => "11.0" }
  s.source       = { :git => "https://github.com/rashadatjou/react-native-awesome-library.git", :tag => "#{s.version}" }

  s.source_files = "ios/**/*.{h,m,mm,swift}"

  # Use install_modules_dependencies helper to install the dependencies if React Native version >=0.71.0.
  # See https://github.com/facebook/react-native/blob/febf6b7f33fdb4904669f99d795eba4c0f95d7bf/scripts/cocoapods/new_architecture.rb#L79.
  if respond_to?(:install_modules_dependencies, true)
    install_modules_dependencies(s)
  else
    s.dependency "React-Core"

    # Don't install the dependencies when we run `pod install` in the old architecture.
    if ENV['RCT_NEW_ARCH_ENABLED'] == '1' then
      s.compiler_flags = folly_compiler_flags + " -DRCT_NEW_ARCH_ENABLED=1"
      s.pod_target_xcconfig    = {
          "HEADER_SEARCH_PATHS" => "\"$(PODS_ROOT)/boost\"",
          "OTHER_CPLUSPLUSFLAGS" => "-DFOLLY_NO_CONFIG -DFOLLY_MOBILE=1 -DFOLLY_USE_LIBCPP=1",
          "CLANG_CXX_LANGUAGE_STANDARD" => "c++17"
      }
      s.dependency "React-RCTFabric"
      s.dependency "React-Codegen"
      s.dependency "RCT-Folly"
      s.dependency "RCTRequired"
      s.dependency "RCTTypeSafety"
      s.dependency "ReactCommon/turbomodule/core"
    end
  end
end

```

I won't go into detail and explain what each line here does. The one thing that we are going to remember is the `s.dependency` declarations as that is how we are adding `CocoaPods` dependencies to our project.

To add our desired `Wowza Flowplayer SDK` dependency into our project we are going to add the following right before the `if statement`:

```ruby
# Set FlowplayerSDK dependency
s.dependency "FlowplayerSDK", '~> 4.1.0'
s.dependency "GoogleAds-IMA-iOS-SDK", '~> 3.19.1'
```

All goody, now to run the `yarn` again to install these dependencies. I recommend everyone to always run `yarn clean` then `yarn` just to be sure no pesky bugs arise.

```bash
¬ª yarn clean
¬ª yarn
```

Response:

```bash
error Command failed with exit code 1.
```

But why did it fail? The issue stems that we have already setup our dependencies in our `example/ios/` project and we need to now go purge everything there and restart the installation process.

```bash
¬ª cd example/ios/
¬ª la -a
‚Äì .xcode.env
‚Äì AwesomeLibraryExample
‚Äì AwesomeLibraryExample-Bridging-Header.h
‚Äì AwesomeLibraryExample.xcodeproj
‚Äì AwesomeLibraryExample.xcworkspace
‚Äì AwesomeLibraryExampleTests
‚Äì build
‚Äì File.swift
‚Äì Podfile
‚Äì Podfile.lock # delete this
‚Äì Pods # delete this
```

```bash
¬ª rm -rf Podfile.lock Pods
```

Awesome by deleting these 2 files now when we run `yarn` again we are going to force CocoaPods to install all dependencies again without any errors.

There is one more extra step we need to do before we can install our dependencies. We need to update the minimum development version of our `example` to iOS 14 as our dependencies require that (you can skip this part if your dependency doesn't require iOS 13 or above)

To accomplish this we are going to need to update both the `Podfile` and our Xcode project.

Update `Podfile` from this:

```bash
¬ª cat Podfile

# Resolve react_native_pods.rb with node to allow for hoisting
require Pod::Executable.execute_command('node', ['-p',
  'require.resolve(
    "react-native/scripts/react_native_pods.rb",
    {paths: [process.argv[1]]},
  )', __dir__]).strip

platform :ios, min_ios_version_supported
prepare_react_native_project!

.
.
.
```

To this:

```bash
¬ª cat Podfile

# Resolve react_native_pods.rb with node to allow for hoisting
require Pod::Executable.execute_command('node', ['-p',
  'require.resolve(
    "react-native/scripts/react_native_pods.rb",
    {paths: [process.argv[1]]},
  )', __dir__]).strip

min_ios_versions_supported = ['14.0', min_ios_version_supported]
index_of_max = min_ios_versions_supported.each_with_index.max_by { |number, _| number.to_f }[1]
platform :ios, min_ios_versions_supported[index_of_max]
prepare_react_native_project!

.
.
.
```

Now open your `*.xcworkspace` file and do the following:

![Xcode Image](/assets/blog2xcode.jpeg)

> Voil√† we are done üòÖ finally we can start install our dependencies...

Now go back to root of our project install the dependencies:

```bash
¬ª cd ../..
¬ª yarn clean
¬ª yarn
```

Output:

```bash
Pod installation complete! There are 64 dependencies from the Podfile and 56 total pods installed.
‚ú®  Done in 18.88s.
```

DONE AND DONE.

## Step 5 using our 3rd party dependency

We can finally do what React Native promised us that we can concentrate on the coding without worrying about the platform specific details üòâ.

Let's open our `ios/AwesomeLibraryViewManager.swift` project with Xcode and add our platform specific code:

```swift
import FlowplayerSDK

// Add the code for setup here
```

Note that there is not going to be any intellisense as Xcode at this point doesn't know what is inside of `FlowplayerSDK`. Good luck though anyway üòÖ. This is due to how Objective-C allows us to link dependencies during run-time so the compiler doesn't care if you add import something that doesn't actually exists.

## Conclusion

We had to do a lot of platform specific tinkering to actually load our dependency in such a manner that we can update at anytime using our CLI and `CocoaPods`. I hope that this blog helps out some poor soul that needs to go trough the same hell as I did because this was not fun at all.

If you are interested in a part 2 of the blog where I actually go and write code instead of setting up the development environment send an email using my portfolio website.

Cheers,
Mehdi Rashadatjou.

<br />
