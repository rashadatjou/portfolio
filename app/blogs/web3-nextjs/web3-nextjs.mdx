---
meta:
  name: "web3-nextjs"
  title: "dApp powered by Auth.js, Web3 and NextJS 14"
  description: "Integrating Auth.js with Web3 Credentials Provider in Next.js 14."
  date: "2024-05-15T18:18:25Z"
  tags: ["nextjs", "web3", "next-auth", "auth"]
headers:
  Cache-Control: max-age=604800
---

import { prettyPrintDate } from "~/utils/date.ts";
import TableOfContents from "~/components/TableOfContents";
import tos from "./tos.ts";

# {meta.title}

<time datetime={meta.date}>
  {prettyPrintDate(meta.date, null, { dateStyle: "long" })}
</time>

---

In this tutorial, we will integrate NextAuth (now rebranded as Auth.js) with a Web3 credentials provider in a Next.js 14 application. We'll use `WalletConnect`, `Wagmi`, and `SIWE` (Sign-In With Ethereum) to create a robust authentication flow. This guide is designed for users with basic programming knowledge and aims to provide a clear, step-by-step approach.

<TableOfContents data={tos} />

## Prerequisites

• Basic knowledge of NextJS and React

• Node.js and npm installed

• Familiarity with Web3 concepts

## Route and Component in Next.js 14

To start, create a new Next.js 14 project and install the necessary dependencies:

```bash
npx create-next-app@latest my-web3-app
```

```bash
cd my-web3-app
```

```bash
npm install next-auth@latest
```

Next.js 14 uses an app directory structure. We will create components and routes accordingly.

## Pages

We will create three main pages for our application:

### Landing

The landing page is the entry point of our application.

```javascript
// app/page.tsx
import Link from "next/link";

export default function LandingPage() {
  return (
    <div className="flex justify-center items-center h-screen">
      <Link href="/auth">
        <button className="bg-blue-500 text-white p-4 rounded">Login</button>
      </Link>
    </div>
  );
}
```

### Auth

The Auth page handles wallet connection and message signing. Users connect their Web3 wallet and sign a message for authentication, creating a signed message to verify their identity.

```javascript
//app/auth/page.tsx
import { useEffect, useState } from "react";

export default function AuthPage() {
  const [mounted, setMounted] = useState < boolean > false;
  // TODO: Use our shiny useWeb3Auth() hook to connect to Web3

  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) return null;

  return (
    <main className="flex min-h-screen flex-col items-center justify-center bg-background text-white">
      <div className="container flex flex-col items-center justify-center gap-12 px-4 py-16 ">
        <h1 className="text-5xl font-extrabold tracking-tight text-foreground sm:text-[5rem]">
          Auth
        </h1>
        <button>Connect Wallet</button>
      </div>
    </main>
  );
}
```

### Protected

The Protected page is for authenticated users only. After authentication, users can navigate here to see user-specific info, like their wallet address, and can sign out.

```javascript
// app/protected/page.tsx
"use client";
import { useSession, signOut } from "next-auth/react";
import { useRouter } from "next/router";
import { useEffect } from "react";

export default function ProtectedPage() {
  const { data: session, status } = useSession();
  const router = useRouter();

  useEffect(() => {
    if (status === "unauthenticated") {
      router.push("/auth");
    }
  }, [status]);

  if (status === "loading") {
    return <div>Loading...</div>;
  }

  return (
    <div className="flex justify-center items-center h-screen">
      {session ? (
        <div>
          <p>Welcome, {session.user.address}</p>
          <button
            onClick={() => signOut()}
            className="bg-red-500 text-white p-4 rounded">
            Sign Out
          </button>
        </div>
      ) : (
        <div>Redirecting...</div>
      )}
    </div>
  );
}
```

## Web3 Integration

## WAGMI?

WAGMI is a collection of React hooks and utilities designed to help developers build Web3 applications with ease. It provides a streamlined and efficient way to interact with Ethereum and other EVM-compatible blockchains. By using WAGMI, developers can handle common Web3 tasks such as connecting wallets, signing messages, and managing blockchain interactions.

### Install WAGMI

```javascript
npm install wagmi viem@2.x @tanstack/react-query
```

• [Viem](https://viem.sh) is a TypeScript interface for Ethereum that performs blockchain operations.

• [TanStack Query](https://tanstack.com/query/v5) is an async state manager that handles requests, caching, and more.

### Setup WAGMI Config

Create a new directory inside of `src/` called `web3/`. Here we are going to host all our Web3 related goodies.

```bash
mkdir src/web3
```

Now create a new directory called `wagmi` inside of `web3`

```bash
mkdir src/web3/wagmi
```

### Integrate WAGMI Provider

We need to create a _Context Provider_ that is required so that WAGMI can function.

> **NOTE:** We are not going to create a WAGMI `Config` as we are going to do that in the next step when we setup `@web3modal` and hook into WAGMI with it.

Inside of the `web3/wagmi/` directory create a new file called `provider.tsx`:

```bash
touch src/web3/wagmi/provider.stx
```

Add the following code to the `provider.tsx`:

```javascript
// src/web3/wagmi/provider.tsx

"use client";

import type { PropsWithChildren } from "react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { type Config, type State, WagmiProvider } from "wagmi";

const client = new QueryClient();

type Props = PropsWithChildren<{
  config: Config,
  initialState?: State,
}>;

const Provider = ({ children, config, initialState }: Props) => {
  return (
    <WagmiProvider config={config} initialState={initialState}>
      <QueryClientProvider client={client}>{children}</QueryClientProvider>
    </WagmiProvider>
  );
};

export default Provider;
export type ProviderProps = Props;
```

Now that looks a lot better doesn't it? We have completely separated our WAGMI code so that id doesn't get in the way...

We are going to create a config and pass it to the WAGMI provider later on but for now we have a clean provider we can use inside of our dApp.

## Web3Modal + WAGMI

We are going to use `@web3modal` as our nifty way to connect to our wallet of choice.
One great thing about `@web3modal` is that is offers an out of the box integration with `wagmi`.
This way we only need a couple of lines of code to set up the model and use it in our dApp.

### Install `@web3modal/wagmi`

Lets add the dependency so that we can start the integration:

```bash
npm install @web3modal/wagmi
```

### Create our WAGMI/Web3Modal config

The `web3model` integrates directly into our WAGMI config. This done so that the modal
can have the following information that it requires to function: WalletConnect, Coinbase and Injected connectors and WalletConnects Blockchain API as a transport.

We can automagically use all of this by using the `defaultWagmiConfig` method from `web3model` instead of the `createConfig` provided by WAGMI. To achieve this I am going to create a `web3model.utils.ts` file which will expose a `createWagmiConfig` method that will handle the creation of an WAGMI Config.

> **NOTE:** Every dApp that relies on WalletConnect now needs to obtain a projectId from WalletConnect [Cloud](https://cloud.walletconnect.com). This is absolutely free and only takes a few minutes.

First lets create a new `web3modal` directory inside of our `web3` directory that is going to hold all our `web3modal` code:

```bash
mkdir app/web3/web3modal
```

Create the config file:

```bash
touch app/web3/web3modal/config.ts
```

Add the following code to it `config.ts`:

```javascript
"use client";

import { defaultWagmiConfig } from "@web3modal/wagmi/react/config";
import { cookieStorage, createStorage } from "wagmi";
import { mainnet, sepolia } from "wagmi/chains";

export const projectId = process.env.NEXT_PUBLIC_WALLET_CONNECT_ID;

const chains = [mainnet, sepolia] as const;

const metadata = {
  name: "My dApp",
  description: "Used to connect your wallet to use dApp",
  url: "http://localhost:3000",
  icons: [],
};

// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call
export const config = defaultWagmiConfig({
  chains,
  projectId,
  metadata,
  ssr: true,
  storage: createStorage({
    storage: cookieStorage,
  }),
});
```

We just created our config that is going to be used by both WAGMI and `@web3modal`. I have setup the config with the support for mainnet and sepolia for now but we can upgrade this at any moment later on. What we are interested in is that we also need to export the `projectId` as it is going to be used outside of the config as well.

### Create our Web3ModalProvider

Another Provider? Really? Not really...

To facilitate all the code that is required by `web3modal` into a single file we are going to create a wrapper around our already created `WagmiProvider`. This wrapper is going to initialize the `web3modal` and load the `WagmiProvider` with the proper state and config.

Create a new file called `provider` inside of `web3modal`:

```bash
touch app/web3/web3modal/provider.tsx
```

Add the following code to the file:

```javascript
"use client";

import type { PropsWithChildren } from "react";
import { cookieToInitialState } from "wagmi";
import { config, projectId } from "~/web3/web3model/config";
import { createWeb3Modal } from "@web3modal/wagmi/react";
import WagmiProvider from "~/web3/wagmi/provider";

type Props = PropsWithChildren<{
  cookie?: string | null,
}>;

createWeb3Modal({
  wagmiConfig: config,
  projectId,
});

export default function Provider({ children, cookie }: Props) {
  const initialState = cookieToInitialState(config, cookie);
  return (
    <WagmiProvider config={config} initialState={initialState}>
      {children}
    </WagmiProvider>
  );
}
```

As mentioned above we have a nice simple provider that initializes all the things needed for the `web3modal` provider in a nice and easy way to use. The only thing we actually need to pass down is an optional `cookie` prop if we want to provide initial state to our `WagmiProvider`.

To use this clean provider lets open the root layout inside of `app/layout.tsx` and add the following code to it:

```javascript
import { headers } from "next/headers";
import Web3ModelProvider from "~/web3/web3model/provider";

export const metadata = {
  title: "My dApp",
  description: "Some crazy life altering dApp",
  icons: [{ rel: "icon", url: "/favicon.ico" }],
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode,
}) {
  return (
    <html lang="en">
      <body>
        <Web3ModelProvider cookie={headers().get("cookie")}>
          {children}
        </Web3ModelProvider>
      </body>
    </html>
  );
}
```

That is it. We can use all `web3modal` related data inside of our dApp without any hassle. In the next steps we are going to create an simple and easy to use hook that will handle the wallet connection.

## SIWE?

SIWE (Sign-In With Ethereum) is an authentication standard that allows users to sign in to applications using their Ethereum wallet. It ensures that the authentication process is secure and decentralized by leveraging the cryptographic signatures provided by Ethereum wallets.
